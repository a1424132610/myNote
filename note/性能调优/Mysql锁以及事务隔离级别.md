# 1、锁分类
- 从性能上分为乐观锁（版本比对）和悲观锁
- 对数据库操作的类型分为读锁和写锁（都属于悲观锁）
 - 读锁（共享锁）：同一份数据，多个读操作可以同时进行不会相互影响
 - 写锁（排它锁）：当前写操作没有完成前，它会阻断其他写锁和读锁
- 从对数据操作的粒度分为，表锁和行锁

```
MyISAM：
表锁：
 每次都锁住整张表，开销小，加锁快；不会出现死锁；锁的粒度大，发生锁冲突的概率最高，并发度最低
表锁一般用在需要数据迁移的时候，做全表操作时候

InnoDB：
行锁：
 每次锁操作锁住一行数据，开销大，加锁慢；会出现死锁；锁粒度最小，发生锁冲突的概率最低，并发度最高。commit之后就会释放掉锁
 
 并发带来的问题：
 更新丢失：
   10个库存，线程1查询出来为10，线程2查询出来也是10，线程1减掉5个库存这时数据库就是5个，而线程2减掉2个库存并且更新到数据库中就成了8
脏读：
   事务1正在对一条数据进行修改，但是没有提交，而事务2查询出已经修改过的数据，但是事务1遇到错误回滚了，这时候事务2查的数据就有问题
不可重复读：
   一个事务读取某些数据后的某个时间，再次读取以前读过的数据，却发现其读出的数据已经发生了改变、或者某个记录被删除了
   一句话：事务A读取到了事务B已经提交的修改过的数据
幻读：
   一个事务按相同的条件查询重新读已经检索过的数据，发现其他事务插入了满足其条件的新数据。
   一句话：事务A读取到了事务B提交的新增数据
 
隔离级别：
    读未提交（Read uncommited） 脏读、不可重复读、幻读都可能
    读已提交（Read commited）不可重复读、幻读可能
    可重复读（Repeatable read）幻读可能
    串行化（Serializable）都不可能
    
间隙锁：（在某些情况下可以解决幻读）
    比如：update account set name='123' where id > 8 and id < 20; 这个时候数据之间的所有间隙就会被锁上，其它事务插入时就会被阻塞，就不能插入进去。
    InnoDB的行锁是针对索引加的锁，不是针对记录加的锁，并且该索引不能失效，否则都会从行锁升级为表锁

死锁：
    查看近期死锁日志信息：show engine innodb status
    大多数情况下mysql可以自动检测死锁并回滚产生死锁的事务

优化锁：
    尽可能让所有的数据检索都通过索引来完成，避免无索引行锁升级为表锁
    合理设计索引，尽量缩小锁的范围
    尽可能减少检索条件范围，避免间隙锁
    尽量控制事务大小，减少锁定资源和时间长度，涉及事务加锁的sql尽量放在最后执行
    尽可能降低事务隔离级别
    
show status like'innodb_row_lock%'; 行锁分析
    Innodb_row_lock_current_waits: 当前正在等待锁定的数量 Innodb_row_lock_time: 从系统启动到现在锁定总时间长度 Innodb_row_lock_time_avg: 每次等待所花平均时间 Innodb_row_lock_time_max：从系统启动到现在等待最长的一次所花时间 Innodb_row_lock_waits:系统启动后到现在总共等待的次数
```