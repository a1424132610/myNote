# 并发专题

### 一、现代计算机的理论模型

![image-20201010142026285](E:%5C%E6%96%87%E6%A1%A3%5Cnote%5Cimgs%5Cimage-20201010142026285.png)

```java
独写速度：寄存器 > L1 > L2 > L3 > 内存条
cpu是通过系统总线去内存条中进行数据交互，每次cpu都会提前把指令copy到cpu cache中以便于提高效率
例如：
 main{
 	a = 1
 }
 cpu先去内存中load到L3然后逐级复制到L1，等写了之后cpu在写回L1然后逐级到L3，同步回内存中是cpu来决定。可以使用 #Lock Mesi缓存一致性协议强制数据在写了之后同步回内存中。
     1、总线加锁：在内存读取时，会给总线进行加锁，其它cpu就不能读写了
     2、缓存一致性协议（MESI）
```

### 二、缓存一致性协议（MESI）

##### 状态：

- M：修改，当前缓存行进行数据修改
- E：独享、互斥
- S：共享
- I：无效

```
main{
	volatile a = 1
}
缓存行：cpu的最小存储单元有可能32字节、64、128字节。
当cpu1读取了volatile关键字描述的（使用#Lock来标识使用MESI）a = 1到缓存当中，总线会一直监听当前内存区域的数据（总线嗅探机制），并且将当前内存数据标识为E状态；当cpu2也来读取了a = 1这个数据到缓存中，那么将这个数据的状态变成S共享的状态。当cpu1修改了 a = 1，那么会将其缓存行锁住，并且将状态改成M修改状态，修改的数据只存在于当前cpu的缓存当中，当cpu1修改完后同步回主内存时，总线嗅探到后会发送消息给cpu2并且将 a = 1的状态改变为I无效状态，并且将整个缓存行丢弃掉。这时候后cpu1中的a又会改成E独享。
如果同一时间都要对a = 1进行修改？
cpu会在一个指令周期内进行裁决，谁赢谁的有效。
什么情况下MESI会失效？
1、如果 a的存储长度大于一个缓存行。如果横跨两个缓存行的话就不能进行加锁，只能加总线锁
2、cpu不支持MESI协议
```

### 三、什么是线程？

